#include "Engine.hpp"
#include "ui/Primitives.hpp"
#include "ui/UIManager.hpp"
#include "util/Color.hpp"
#include <array>
#include <cmath>
#include <cstring>
#include <iostream>
#include <memory>
#include <vector>

#define STB_IMAGE_IMPLEMENTATION
#include "lib/stb_image.h"

// Enable Vulkan validation layers in debug builds.
#ifndef NDEBUG
constexpr bool enableValidationLayers = true;
#else
constexpr bool enableValidationLayers = false;
#endif

constexpr std::array<const char *, 1> validationLayers = {"VK_LAYER_KHRONOS_validation"};

// Link the icon's byte array, which is generated by xxd and compiled separately.
extern "C" {
    extern const unsigned char iro_engine_icon_png[];
    extern const unsigned int iro_engine_icon_png_len;
}

void Engine::run() {
    init();
    mainLoop();
    cleanup();
}

void Engine::init() {
    glfwInit();
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
    window = glfwCreateWindow(INITIAL_WIDTH, INITIAL_HEIGHT, "Iro Engine", nullptr, nullptr);
    glfwSetWindowUserPointer(window, this);
    glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);

    // Load window icon from embedded memory.
    int iconWidth, iconHeight, iconChannels;
    unsigned char *pixels = stbi_load_from_memory(iro_engine_icon_png, iro_engine_icon_png_len, &iconWidth, &iconHeight, &iconChannels, STBI_rgb_alpha);
    if (pixels) {
        GLFWimage images[1];
        images[0].width = iconWidth;
        images[0].height = iconHeight;
        images[0].pixels = pixels;
        glfwSetWindowIcon(window, 1, images);
        stbi_image_free(pixels);
    } else {
        std::cerr << "Warning: Could not load window icon from embedded data.\n";
    }

    createInstance();
    createSurface();

    vDevice = std::make_unique<VDevice>(instance, surface, window);
    vSwapChain = std::make_unique<VSwapChain>(*vDevice, VkExtent2D{INITIAL_WIDTH, INITIAL_HEIGHT});
    vRenderer = std::make_unique<VRenderer>(*vDevice, *vSwapChain, threadResources);
    uiManager = std::make_unique<UIManager>();

    // Multi-thread command resources
    const std::size_t workerCount = std::max(1u, std::thread::hardware_concurrency() - 1u);

    for (auto &frameVec : threadResources) {
        frameVec.resize(workerCount);

        QueueFamilyIndices q = vDevice->findQueueFamilies(vDevice->physicalDevice());
        for (auto &res : frameVec) {
            VkCommandPoolCreateInfo pi {
                .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
                .flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
                .queueFamilyIndex = q.graphicsFamily.value()
            };
            vkCreateCommandPool(vDevice->device(), &pi, nullptr, &res.pool);

            VkCommandBufferAllocateInfo ai {
                .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
                .commandPool = res.pool,
                .level = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
                .commandBufferCount = 1
            };
            vkAllocateCommandBuffers(vDevice->device(), &ai, &res.buffer);
        }
    }

    // UI

    auto squareVerts = Primitives::Vertex::create_default_quad();

    squareVerts[0].color = ColorUtil::rgba_to_uint32_aabbggrr({1.0f, 0.0f, 0.0f, 1.0f});
    squareVerts[1].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 1.0f, 0.0f, 1.0f});
    squareVerts[2].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 0.0f, 1.0f, 1.0f});
    squareVerts[3].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 0.0f, 0.0f, 1.0f});

    auto square = std::make_unique<Primitives::Quad>(*vDevice);
    square->setVertices(squareVerts);
    square->setPosition({0.70f, 0.0f});
    square->setScale({0.5f, 0.5f});
    uiManager->add("square", std::move(square));


    auto triangleVerts = Primitives::Vertex::create_default_triangle();

    triangleVerts[0].color = ColorUtil::rgba_to_uint32_aabbggrr({1.0f, 0.0f, 0.0f, 1.0f});
    triangleVerts[1].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 1.0f, 0.0f, 1.0f});
    triangleVerts[2].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 0.0f, 1.0f, 1.0f});

    auto triangle = std::make_unique<Primitives::Triangle>(*vDevice);
    triangle->setVertices(triangleVerts);
    triangle->setPosition({-0.75f, 0});
    triangle->setScale({0.5f, 0.5f});
    uiManager->add("triangle", std::move(triangle));

    // Discord
    discord = std::make_unique<Discord>();
    discord->init();
}

void Engine::mainLoop() {
    double lastTime = glfwGetTime();
    int frameCount = 0;

    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        discord->update();

        const float t = glfwGetTime();
        ++frameCount;
        if (t - lastTime >= 1.0) {
            std::string title = "Iro Engine - " + std::to_string(frameCount) + " FPS";
            glfwSetWindowTitle(window, title.c_str());
            frameCount = 0;
            lastTime = t;
        }

        const float s = 0.5f + 0.02f * std::sin(t * 5.0f);
        uiManager->get("triangle")->setScale({s, s});

        VkCommandBuffer primary = vRenderer->beginFrame();
        if (!primary)
            continue;

        // Record (or reuse) secondary command buffers in parallel
        auto &frameRes = threadResources[vRenderer->getFrameIndex()];
        const std::size_t workerCount = frameRes.size();
        std::vector<VkCommandBuffer> secondaries;
        secondaries.reserve(workerCount);

        std::size_t w = 0;
        const auto &all = uiManager->getElements();
        auto it = all.begin();

        while (it != all.end()) {
            // Gather up to 64 primitives into one batch
            std::vector<Primitives::Primitive *> batch;
            batch.reserve(64);
            for (std::size_t k = 0; k < 64 && it != all.end(); ++k, ++it)
                batch.push_back(it->second.get());

            const std::size_t id = w++ % workerCount;
            jobSystem.push([&, id, batch] {
                auto &res = frameRes[id];
                const VkFramebuffer fb = vRenderer->getCurrentFramebuffer();

                bool needsRecord = !res.recorded || (res.framebufferUsed != fb);
                if (!needsRecord) {
                    for (auto *p : batch)
                        if (p->dirty()) { needsRecord = true; break; }
                }

                if (!needsRecord) {
                    for (auto *p : batch) p->clearDirty();
                    return;
                }

                vkResetCommandBuffer(res.buffer, 0);

                VkCommandBufferInheritanceInfo inh {
                    .sType       = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
                    .renderPass  = vRenderer->getSwapChainRenderPass(),
                    .subpass     = 0,
                    .framebuffer = fb
                };

                VkCommandBufferBeginInfo bi {
                    .sType            = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
                    .flags            = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT | VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
                    .pInheritanceInfo = &inh
                };
                vkBeginCommandBuffer(res.buffer, &bi);

                VkViewport vp {
                    0, 0,
                    static_cast<float>(vSwapChain->getExtent().width),
                    static_cast<float>(vSwapChain->getExtent().height),
                    0.0f, 1.0f
                };

                VkRect2D sc {{0, 0}, vSwapChain->getExtent()};
                vkCmdSetViewport(res.buffer, 0, 1, &vp);
                vkCmdSetScissor (res.buffer, 0, 1, &sc);

                for (auto *p : batch) {
                    vRenderer->draw(res.buffer, *p);
                    p->clearDirty();
                }

                vkEndCommandBuffer(res.buffer);
                res.recorded        = true;
                res.framebufferUsed = fb;
            });
        }

        jobSystem.wait();

        for (auto &res : frameRes)
            if (res.recorded)
                secondaries.push_back(res.buffer);

        vRenderer->beginSwapChainRenderPass(primary);
        if (!secondaries.empty())
            vkCmdExecuteCommands(primary, static_cast<uint32_t>(secondaries.size()), secondaries.data());
        
        vRenderer->endSwapChainRenderPass(primary);
        vRenderer->endFrame();
    }

    vkDeviceWaitIdle(vDevice->device());
}

void Engine::cleanup() {
    uiManager.reset();
    vRenderer.reset();
    vSwapChain.reset();

    vkDeviceWaitIdle(vDevice->device());

    for (auto &vec : threadResources) {
        for (auto &res : vec) {
            if (res.pool)
                vkDestroyCommandPool(vDevice->device(), res.pool, nullptr);
        }
        vec.clear();
    }

    vDevice.reset();
    discord.reset();

    vkDestroySurfaceKHR(instance, surface, nullptr);
    vkDestroyInstance(instance, nullptr);

    glfwDestroyWindow(window);
    glfwTerminate();
}

void Engine::framebufferResizeCallback(GLFWwindow *window, int width, int height) {
    auto engine = reinterpret_cast<Engine *>(glfwGetWindowUserPointer(window));
    engine->vSwapChain->framebufferResized = true;
}

void Engine::createInstance() {
    VkApplicationInfo appInfo {
        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
        .pApplicationName = "Iro Engine",
        .applicationVersion = VK_MAKE_VERSION(1, 0, 0),
        .pEngineName = "Iro Engine",
        .engineVersion = VK_MAKE_VERSION(1, 0, 0),
        .apiVersion = VK_API_VERSION_1_2,
    };

    uint32_t glfwExtensionCount = 0;
    const char **glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

    VkInstanceCreateInfo createInfo {
        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        .pApplicationInfo = &appInfo,
        .enabledExtensionCount = glfwExtensionCount,
        .ppEnabledExtensionNames = glfwExtensions,
    };

    if (enableValidationLayers) {
        createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
        createInfo.ppEnabledLayerNames = validationLayers.data();
    }

    if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
        throw std::runtime_error("Failed to create Vulkan instance.");
    }
}

void Engine::createSurface() {
    if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
        throw std::runtime_error("Failed to create window surface.");
    }
}
