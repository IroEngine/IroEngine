#include "Engine.hpp"
#include "ui/Primitives.hpp"
#include "util/Color.hpp"
#include <array>
#include <cstring>
#include <iostream>
#include <memory>

#define STB_IMAGE_IMPLEMENTATION
#include "lib/stb_image.h"

// Use compile-time flag to check if validation layers should be enabled.
#ifndef NDEBUG
constexpr bool enableValidationLayers = true;
#else
constexpr bool enableValidationLayers = false;
#endif

// A constexpr array is used for compile-time definition of validation layers.
constexpr std::array<const char *, 1> validationLayers = {
    "VK_LAYER_KHRONOS_validation"};

// Use extern "C" to link the icon byte array generated by xxd.
extern "C" {
    extern const unsigned char iro_engine_icon_png[];
    extern const unsigned int iro_engine_icon_png_len;
}

void Engine::run() {
    init();
    mainLoop();
    cleanup();
}

void Engine::framebufferResizeCallback(GLFWwindow *window, int width,
                                       int height) {
    auto engine = reinterpret_cast<Engine *>(glfwGetWindowUserPointer(window));
    engine->vSwapChain->framebufferResized = true;
}

void Engine::init() {
    glfwInit();
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // Allow resizing
    window = glfwCreateWindow(WIDTH, HEIGHT, "Iro Engine", nullptr, nullptr);
    glfwSetWindowUserPointer(window, this);
    glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);

    int iconWidth, iconHeight, iconChannels;
    unsigned char *pixels =
        stbi_load_from_memory(iro_engine_icon_png, iro_engine_icon_png_len,
                              &iconWidth, &iconHeight, &iconChannels,
                              STBI_rgb_alpha);

    if (pixels) {
        GLFWimage images[1];
        images[0].width = iconWidth;
        images[0].height = iconHeight;
        images[0].pixels = pixels;
        glfwSetWindowIcon(window, 1, images);
        stbi_image_free(pixels);
    } else {
        std::cerr << "Warning: Could not load window icon from embedded data.\n";
    }

    createInstance();
    createSurface();

    vDevice = std::make_unique<VDevice>(instance, surface, window);
    vSwapChain = std::make_unique<VSwapChain>(*vDevice, VkExtent2D{WIDTH, HEIGHT});
    vRenderer = std::make_unique<VRenderer>(*vDevice, *vSwapChain);

    discord = std::make_unique<Discord>();
    discord->init();
}

void Engine::mainLoop() {
    Primitives::Triangle triangle1{};

    triangle1.vertices[0].position = {0.0f, -0.5f};
    triangle1.vertices[0].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 0.0f, 1.0f, 1.0f});

    triangle1.vertices[1].position = {0.5f, 0.5f};
    triangle1.vertices[1].color = ColorUtil::rgba_to_uint32_aabbggrr({1.0f, 0.0f, 0.0f, 1.0f});

    triangle1.vertices[2].position = {-0.5f, 0.5f};
    triangle1.vertices[2].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 1.0f, 0.0f, 1.0f});

    Primitives::Triangle triangle2{};

    triangle2.position_offset = {0.5f, 0.5f};

    triangle2.vertices[0].position = {0.0f, -0.5f};
    triangle2.vertices[0].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 1.0f, 1.0f, 1.0f});

    triangle2.vertices[1].position = {0.5f, 0.5f};
    triangle2.vertices[1].color = ColorUtil::rgba_to_uint32_aabbggrr({1.0f, 0.0f, 1.0f, 1.0f});

    triangle2.vertices[2].position = {-0.5f, 0.5f};
    triangle2.vertices[2].color = ColorUtil::rgba_to_uint32_aabbggrr({1.0f, 1.0f, 0.0f, 1.0f});

    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        discord->update();

        float aspect = vRenderer->getAspectRatio();
        if (aspect > 1.0f) {
            triangle1.scale = {1.0f / aspect, 1.0f};
            triangle2.scale = {1.0f / aspect, 1.0f};
        } else {
            triangle1.scale = {1.0f, aspect};
            triangle2.scale = {1.0f, aspect};
        }

        if (auto cmd = vRenderer->beginFrame()) {
            vRenderer->beginSwapChainRenderPass(cmd);
            vRenderer->draw(cmd, triangle1);
            vRenderer->draw(cmd, triangle2);
            vRenderer->endSwapChainRenderPass(cmd);
            vRenderer->endFrame();
        }
    }

    vkDeviceWaitIdle(vDevice->device());
}

void Engine::cleanup() {
    vRenderer.reset();
    vSwapChain.reset();
    vDevice.reset();

    vkDestroySurfaceKHR(instance, surface, nullptr);
    vkDestroyInstance(instance, nullptr);

    glfwDestroyWindow(window);
    glfwTerminate();

    discord.reset();
}

void Engine::createInstance() {
    VkApplicationInfo appInfo{
        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
        .pApplicationName = "Iro Engine",
        .applicationVersion = VK_MAKE_VERSION(1, 0, 0),
        .pEngineName = "Iro Engine",
        .engineVersion = VK_MAKE_VERSION(1, 0, 0),
        .apiVersion = VK_API_VERSION_1_2,
    };

    uint32_t glfwExtensionCount = 0;
    const char **glfwExtensions =
        glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

    VkInstanceCreateInfo createInfo{
        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        .pApplicationInfo = &appInfo,
        .enabledExtensionCount = glfwExtensionCount,
        .ppEnabledExtensionNames = glfwExtensions,
    };

    if (enableValidationLayers) {
        createInfo.enabledLayerCount =
            static_cast<uint32_t>(validationLayers.size());
        createInfo.ppEnabledLayerNames = validationLayers.data();
    }

    if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
        throw std::runtime_error("Failed to create Vulkan instance.");
    }
}

void Engine::createSurface() {
    if (glfwCreateWindowSurface(instance, window, nullptr, &surface) !=
        VK_SUCCESS) {
        throw std::runtime_error("Failed to create window surface.");
    }
}
