#include "Engine.hpp"
#include "ui/Primitives.hpp"
#include "ui/UIManager.hpp"
#include "util/Color.hpp"
#include <array>
#include <cmath>
#include <cstring>
#include <iostream>
#include <memory>
#include <vector>

#define STB_IMAGE_IMPLEMENTATION
#include "lib/stb_image.h"

// Enable Vulkan validation layers in debug builds.
#ifndef NDEBUG
constexpr bool enableValidationLayers = true;
#else
constexpr bool enableValidationLayers = false;
#endif

constexpr std::array<const char *, 1> validationLayers = {"VK_LAYER_KHRONOS_validation"};

// Link the icon's byte array, which is generated by xxd and compiled separately.
extern "C" {
    extern const unsigned char iro_engine_icon_png[];
    extern const unsigned int iro_engine_icon_png_len;
}

void Engine::run() {
    init();
    mainLoop();
    cleanup();
}

void Engine::init() {
    glfwInit();
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
    window = glfwCreateWindow(INITIAL_WIDTH, INITIAL_HEIGHT, "Iro Engine", nullptr, nullptr);
    glfwSetWindowUserPointer(window, this);
    glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);

    // Load window icon from embedded memory.
    int iconWidth, iconHeight, iconChannels;
    unsigned char *pixels = stbi_load_from_memory(iro_engine_icon_png, iro_engine_icon_png_len, &iconWidth, &iconHeight, &iconChannels, STBI_rgb_alpha);
    if (pixels) {
        GLFWimage images[1];
        images[0].width = iconWidth;
        images[0].height = iconHeight;
        images[0].pixels = pixels;
        glfwSetWindowIcon(window, 1, images);
        stbi_image_free(pixels);
    } else {
        std::cerr << "Warning: Could not load window icon from embedded data.\n";
    }

    createInstance();
    createSurface();

    vDevice = std::make_unique<VDevice>(instance, surface, window);
    vSwapChain = std::make_unique<VSwapChain>(*vDevice, VkExtent2D{INITIAL_WIDTH, INITIAL_HEIGHT});
    vRenderer = std::make_unique<VRenderer>(*vDevice, *vSwapChain);
    uiManager = std::make_unique<UIManager>();

    // UI

    auto squareVerts = Primitives::Vertex::create_default_quad();

    squareVerts[0].color = ColorUtil::rgba_to_uint32_aabbggrr({1.0f, 0.0f, 0.0f, 1.0f});
    squareVerts[1].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 1.0f, 0.0f, 1.0f});
    squareVerts[2].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 0.0f, 1.0f, 1.0f});
    squareVerts[3].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 0.0f, 0.0f, 1.0f});

    auto square = std::make_unique<Primitives::Quad>(*vDevice);
    square->setVertices(squareVerts);
    square->setPosition({0.70f, 0.0f});
    square->setScale({0.5f, 0.5f});
    uiManager->add("square", std::move(square));


    auto triangleVerts = Primitives::Vertex::create_default_triangle();

    triangleVerts[0].color = ColorUtil::rgba_to_uint32_aabbggrr({1.0f, 0.0f, 0.0f, 1.0f});
    triangleVerts[1].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 1.0f, 0.0f, 1.0f});
    triangleVerts[2].color = ColorUtil::rgba_to_uint32_aabbggrr({0.0f, 0.0f, 1.0f, 1.0f});

    auto triangle = std::make_unique<Primitives::Triangle>(*vDevice);
    triangle->setVertices(triangleVerts);
    triangle->setPosition({-0.75f, 0});
    triangle->setScale({0.5f, 0.5f});
    uiManager->add("triangle", std::move(triangle));

    // Discord
    discord = std::make_unique<Discord>();
    discord->init();
}

void Engine::mainLoop() {
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        discord->update();

        // Animate the busy indicator.
        float time = glfwGetTime();
        float scale = 0.5f + 0.02f * sin(time * 5.0f);
        uiManager->get("triangle")->setScale({scale, scale});

        // Render the scene.
        if (auto cmd = vRenderer->beginFrame()) {
            vRenderer->beginSwapChainRenderPass(cmd);

            for (const auto &pair : uiManager->getElements()) {
                vRenderer->draw(cmd, *pair.second);
            }

            vRenderer->endSwapChainRenderPass(cmd);
            vRenderer->endFrame();
        }
    }
    vkDeviceWaitIdle(vDevice->device());
}

void Engine::cleanup() {
    uiManager.reset();
    vRenderer.reset();
    vSwapChain.reset();
    vDevice.reset();
    discord.reset();

    vkDestroySurfaceKHR(instance, surface, nullptr);
    vkDestroyInstance(instance, nullptr);

    glfwDestroyWindow(window);
    glfwTerminate();
}

void Engine::framebufferResizeCallback(GLFWwindow *window, int width, int height) {
    auto engine = reinterpret_cast<Engine *>(glfwGetWindowUserPointer(window));
    engine->vSwapChain->framebufferResized = true;
}

void Engine::createInstance() {
    VkApplicationInfo appInfo {
        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
        .pApplicationName = "Iro Engine",
        .applicationVersion = VK_MAKE_VERSION(1, 0, 0),
        .pEngineName = "Iro Engine",
        .engineVersion = VK_MAKE_VERSION(1, 0, 0),
        .apiVersion = VK_API_VERSION_1_2,
    };

    uint32_t glfwExtensionCount = 0;
    const char **glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

    VkInstanceCreateInfo createInfo {
        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        .pApplicationInfo = &appInfo,
        .enabledExtensionCount = glfwExtensionCount,
        .ppEnabledExtensionNames = glfwExtensions,
    };

    if (enableValidationLayers) {
        createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
        createInfo.ppEnabledLayerNames = validationLayers.data();
    }

    if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
        throw std::runtime_error("Failed to create Vulkan instance.");
    }
}

void Engine::createSurface() {
    if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
        throw std::runtime_error("Failed to create window surface.");
    }
}
